1. Check for sorted rotated array : you are given an array and you need to find if it is sorted and rotated once. consider case like:[2,1,3,4].
2. Kadane's philosophy : If some part of past is adding negative value or decreasing your potential then ignore the past. and move on with the present :).
3. Longest Consecutive Sequence : in a given array you have to find longest consecutive seq possible ex: [1,9,4,2,6,7] ans:[1,2,4] for this place the array in a set. then for every element see if element-1 is present in the set. if present skip else search for element+1,element+2 ... until it breaks it takes around O(3n).
4. Set Zero Matrix : if a mat[i][j] is 0 then set all elements in row i and col j as 0.for this use col 0, row 0 as indicators if that row needs to be zeroed or col to be zeroed. handle col0 case separately.
5. 90 degrees rotation.
6. Inversion counts: merge sort.
7. Maximum Product subarray: maintain postivie_product,negative_product in each iteration pp=max({nums[i],nums[i]*pp,nums[i]*np}), np= min({nums[i],nums[i]*pp,nums[i]*np}) res=max(res,pp);
